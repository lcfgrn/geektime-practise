# 本地缓存/远程缓存

## 数据分类

- 静态数据：一般不变
- 准静态数据：变化频率很低，部门结构设置，全国行政区划数据等
- 中间状态数据： 一些计算的可复用的中间数据，变量副本，配置中心的本地副本

这种数据适合使用缓存

- 热数据：使用频率高
- **读写比**较大：读的频率>>写的频率

##  缓存的本质

系统各级处理不匹配，导致利用**空间换时间**

缓存是**提升系统性能**的一个简单有效的方法

## 缓存加载的时机

1. 启动时**全量加载**==>全局有效，使用简单
2. **懒加载**
   1. 同步使用加载
      1. 先看缓存是否有数据，没有的话，从数据库读取
      2. 读取的数据，先放到缓存，然后返回给调用方
   2. 延迟异步加载
      1. 从缓存获取数据，不管是否为空直接返回（没有直接返回为空）
      2. 策略1异步） 如果为空，则发起一个异步加载的线程，负载加载数据
      3. 策略2解耦） 异步线程负责维护缓存的数据，定期或根据条件触发更新

## 为什么说变动频率大、一致性要求高的数据，不太适合用缓存？

变化大，意味着内存缓存数据与原始数据库，一直有差异

一致性要求高，意味着只有使用原始数据才是保险的

## 如何评价缓存的有效性？

**读写比**：对数据的写操作导致数据变动，意味着维护成本

**命中率**：命中缓存意味着缓存数据被使用，意味着有价值

## 缓存使用不当导致的问题

1. 系统预热导致启动慢
   1. 导致系统不能做到快速应对故障后的启动
2. 系统内存资源耗尽
   1. 只加入数据，不清理旧数据

## 最简单的本地缓存

```java
public static final Map<String,Object> CACHE = new HashMap();
```

## Hibernate/MyBatis都有Cache

一级缓存，session级别

二级缓存，sessionFactory级别

## Guava Cache

```java
Cache<String, String> cache = CacheBuilder.newBuilder()
                .maximumSize(1024)
                .expireAfterWrite(60, TimeUnit.SECONDS)
                .weakValues()
                .build();	
```

## Spring Cache

1. 基于注解和AOP，使用非常方便
2. 可以配置Condition和SPEL，非常灵活
3. 需要注意：绕过Spring的话，注解无效

核心功能：@Cacheable、 @CachePut、@CacheEvict

## 本地缓存的缺点

1. 当集群规模增大，缓存的读写放大
2. 在JVM长期占用内存，影响GC
3. 缓存数据的调度处理，影响业务线程，抢资源

## Memcached/Redis缓存中间件

一代缓存

## Hazelcast/Ignite内存网格

二代缓存

##  过期策略

- 按FIFO或LRU
- 按**固定时间**过期
- 按业务时间加权：例如3+5x （查询第一天的机票，缓存3分钟，查询第二天缓存8分钟，第三天缓存13分钟） 

# 缓存常见的一些问题

## 缓存穿透

**大量并发查询不存在的KEY**，导致直接将压力透传到数据库

需要注意让缓存能够区分KEY不存在和查询到一个空值

解决办法：

1. **缓存空值**的KEY，这样第一次不存在也会
2. **Bloom过滤**或**RoaringBitmap**判断KEY是否存在
3. 完全以缓存为准，使用**延迟异步加载**的策略2，这样就不会触发更新

## 缓存击穿

某个KEY失效的时候，正好有大量并发请求访问这个KEY（比较偶然）

解决方法：

1. KEY的更新操作添加**全局互斥锁**(锁加在KEY上)
2. 完全以缓存为准，使用**延迟异步加载**的策略2，这样就不会触发更新

## 缓存雪崩

当**某一时刻发生大规模的缓存失效**的情况，会有大量的请求进来直接打到数据库，导致数据库压力过大甚至宕机

需要我们的更新策略要在时间上合适，数据要均匀分散，缓存服务器要多台高可用。

解决办法：

1. 更新策略在时间上做到比较均匀
2. 使用的热数据尽量分散到不同的机器上
3. 多台机器做主从复制或者多副本，实现高可用
4. 实现熔断限流机制，对系统进行负载能力控制。

