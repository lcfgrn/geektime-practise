# 多线程学习笔记

## 多线程基础

### 为什么会有多线程

本质原因：摩尔定律的失效-->多核+分布式时代的来临

 <img src="./image/多CPU核心的设计.png" alt="多CPU核心设计" style="zoom:100%;" />

NUMA架构可扩展性更好，SMP架构中CPU对同一内存的竞争太强

### Java线程的创建过程

<img src="./image/Java线程的创建过程.png" alt="Java线程的创建过程" style="zoom:150%;" />

## Java多线程

### 关于守护线程

主线程在执行时，系统如果发现其他线程都是守护线程，会马上结束进程。 

### 关于线程的start()和run()

- Thread#start():创建新线程
- Thread#run() : 本线程调用  

### 线程状态

<img src="./image/线程状态.png" alt="线程状态" style="zoom:150%;" />

### Thread类的重要属性和方法

| 重要属性/方法                          | 说明                              |
| :------------------------------------- | --------------------------------- |
| volatile String name;                  | 线程名称                          |
| boolean daemon = false;                | 后台守护线程标志——决定JVM优雅关闭 |
| Runnable target;                       | 任务（只能通过构造函数传入）      |
| synchronized void start()              | 启动新线程并自动执行              |
| void join()                            | [协作] 等待某个线程执行完毕       |
| static native Thread currentThread();  | 获取当前线程信息                  |
| static native void sleep(long millis); | 线程睡眠并让出CPU时间片           |

### wait&notify

| Object#方法                        | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| void wait()                        | 释放锁+等待0ms+唤醒后，尝试获取锁                            |
| void wait(long timeout, int nanos) | 释放锁+wait+到时间自动唤醒/中途唤醒（精度：nanos>0，则timeout+1) |
| native void wait(long timeout)     | 释放锁+wait+到时间自动唤醒/中途唤醒（唤醒之后需要自动获取锁） |
| native void notify()               | 发送信号通知1个等待线程                                      |
| native void notifyAll()            | 发送信号通知所有等待线程                                     |

- Thread.sleep：释放CPU，不释放锁

- Object#wait：释放对象锁和CPU

### Thread的状态改变操作

1. **Thread.sleep(long millis)**，一定是当前线程调用此方法，当前线程进入 TIMED_WAITING 状态，但不释放对象锁，millis 后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。
2.  **Thread.yield()**，一定是当前线程调用此方法，当前线程放弃获取的 CPU 时间片，但不释放锁资源，由运行状态变为就绪状态，让 OS 再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中Thread.yield() 不会导致阻塞。该方法与sleep() 类似，只是不能由用户指定暂停多长时间。
3. **t.join()/t.join(long millis)**，当前线程里调用其它线程 t 的 join 方法，当前线程进入WAITING/TIMED_WAITING 状态，当前线程不会释放已经持有的对象锁，因为内部调用了 t.wait，所以会释放t这个对象上的同步锁。线程 t 执行完毕或者 millis 时间到，当前线程进入就绪状态。其中，wait 操作对应的 notify 是由 jvm 底层的线程执行结束前触发的。
4. **obj.wait()**，当前线程调用对象的 wait() 方法，当前线程释放 obj 对象锁，进入等待队列。依靠 notify()/notifyAll()唤醒或者 wait(long timeout) timeout 时间到自动唤醒。唤醒会，线程恢复到 wait 时的状态。
5.  **obj.notify()** 唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll() 唤醒在此对象监视器上等待的所有线程。

### Thread的中断与异常处理

1. 线程内部自己处理异常，不溢出到外层（Future除外）

2. 如果线程被**Object.wait, Thread.join和Thread.sleep**三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个**InterruptedException中断异常**（该线程必须事先预备好处理此异常），从而**提早终结**被阻塞状态。

3. 如果线程没有被阻塞，这时调用 interrupt() 将不起作用，直到执行到wait/sleep/join 时，才马上会抛出InterruptedException。

   #### 如果是计算密集型操作怎么办？

   分段处理，每个片段检查一下状态，是不是要终止  

### Thread状态

<img src="./image/Thread的RWB.png" alt="Thread的RWB" style="zoom:150%;" />

可以简化记忆为**RWB**

## 线程安全

